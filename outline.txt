

[introduction]
	• the problem
		-testing is hard, etc
		-why most solutions fail
	• justification / a new solution
		
[the field]
	• why software testing is important
	• how software is tested
	• why software isn't often tested well
	• software testing problems
		- why it can be hard to get right
		- costs of failure
	• test smells
	
[testing]
	• current practices/overview
		- white box, black-box, gray-box
		- test driven development
		- unit testing
	• testing methods
	• random/combinatorial/…/mocking/unit testing
	• why they work
	• why they fail
	• testing in theory
	
[falcon language]
	• overview 
		- why a dsl
		- why it is the way it is
		- its broad applicabilty
	• aims to make building tests easier
		• possibly 'pure' or blind & optimized
	• adaptive design
		- many ways to do things
		- lots of room to improve/adapt/modify
	• justification
	• frameworks vs academia or practice vs literature
	• semantics
	• how it is used
	• (simple) examples
	• pros/cons
	
[examples]
	• example problems
	• how the examples compare
	• what works
	• what doesn't work
	• future work/improvements
	
	
[thoughts/observations]

• Easier to learn - one language for all test
• Can be more comprehensive than any one framework or tool or tool-set
• Unifies test methodologies - there are many philosophies, styles, types, methods, etc - but hard to bring under one umbrella
	--> there exist so many ways because no one way works or one tool
• Can use the language of Computer Science/Math/Logic
• Python tests look like Python or C++/JavaScript/etc → a chance to reflect using a more reasoned approach
• separates test from code
• by separating tests from language - intent can become clearer. Like what is this software
	doing and how could we re-write it.
• software testing is a skill in an of itself. One language builds the skill while 
	avoiding one framework
• testing is often verbose, difficult to express simple tests without lots of code
